"""Credential Validator - validates leaked credentials"""
import requests
from typing import List, Dict, Optional
import concurrent.futures

class CredentialValidator:
    """Validates leaked credentials against various services"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        self.validated_creds = []
    
    def validate_credentials(self, credentials: List[Dict]) -> List[Dict]:
        """Validate list of credentials"""
        results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(self._validate_single_credential, cred) for cred in credentials]
            for future in concurrent.futures.as_completed(futures, timeout=120):
                try:
                    result = future.result()
                    if result and result.get('valid'):
                        results.append(result)
                        self.validated_creds.append(result)
                except:
                    pass
        return results
    
    def _validate_single_credential(self, cred: Dict) -> Optional[Dict]:
        """Validate single credential"""
        cred_type = cred.get('type', '')
        value = cred.get('value', '')
        if not value:
            return None
        
        result = {
            'original': cred,
            'type': cred_type,
            'value': value,
            'valid': False,
            'service': None,
            'details': {}
        }
        
        validators = {
            'aws_access_key': self._validate_aws_key,
            'github_token': self._validate_github_token,
            'slack_token': self._validate_slack_token,
            'google_api': self._validate_google_api,
            'stripe_key': self._validate_stripe_key,
            'sendgrid_key': self._validate_sendgrid_key,
            'database_url': self._validate_database_url
        }
        
        if cred_type in validators:
            result.update(validators[cred_type](value))
        elif cred_type in ['password', 'token', 'secret']:
            result.update(self._validate_generic_credential(value))
        
        return result if result.get('valid') else None
    
    def _validate_aws_key(self, access_key: str) -> Dict:
        """Validate AWS access key"""
        try:
            import boto3
            from botocore.exceptions import ClientError
            
            # Try with common secrets
            for secret in self._generate_secret_candidates(access_key):
                try:
                    client = boto3.client('sts', aws_access_key_id=access_key, aws_secret_access_key=secret)
                    response = client.get_caller_identity()
                    return {
                        'valid': True,
                        'service': 'AWS',
                        'secret_key': secret,
                        'account_id': response.get('Account'),
                        'user_id': response.get('UserId'),
                        'arn': response.get('Arn')
                    }
                except ClientError:
                    continue
        except ImportError:
            pass
        return {'valid': False}
    
    def _validate_github_token(self, token: str) -> Dict:
        """Validate GitHub token"""
        try:
            headers = {'Authorization': f'token {token}'}
            resp = self.session.get('https://api.github.com/user', headers=headers, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                return {
                    'valid': True,
                    'service': 'GitHub',
                    'username': data.get('login'),
                    'user_id': data.get('id'),
                    'email': data.get('email')
                }
        except:
            pass
        return {'valid': False}
    
    def _validate_slack_token(self, token: str) -> Dict:
        """Validate Slack token"""
        try:
            resp = self.session.post('https://slack.com/api/auth.test', data={'token': token}, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                if data.get('ok'):
                    return {
                        'valid': True,
                        'service': 'Slack',
                        'team': data.get('team'),
                        'user': data.get('user'),
                        'url': data.get('url')
                    }
        except:
            pass
        return {'valid': False}
    
    def _validate_google_api(self, key: str) -> Dict:
        """Validate Google API key"""
        try:
            resp = self.session.get(f'https://maps.googleapis.com/maps/api/geocode/json?address=test&key={key}', timeout=10)
            if resp.status_code == 200 and 'OK' in resp.text:
                return {'valid': True, 'service': 'Google API'}
        except:
            pass
        return {'valid': False}
    
    def _validate_stripe_key(self, key: str) -> Dict:
        """Validate Stripe key"""
        try:
            resp = self.session.get('https://api.stripe.com/v1/balance', auth=(key, ''), timeout=10)
            if resp.status_code == 200:
                return {'valid': True, 'service': 'Stripe'}
        except:
            pass
        return {'valid': False}
    
    def _validate_sendgrid_key(self, key: str) -> Dict:
        """Validate SendGrid key"""
        try:
            headers = {'Authorization': f'Bearer {key}'}
            resp = self.session.get('https://api.sendgrid.com/v3/user/profile', headers=headers, timeout=10)
            if resp.status_code == 200:
                return {'valid': True, 'service': 'SendGrid'}
        except:
            pass
        return {'valid': False}
    
    def _validate_database_url(self, db_url: str) -> Dict:
        """Validate database connection string"""
        try:
            if db_url.startswith('mongodb://'):
                return self._test_mongodb(db_url)
            elif db_url.startswith('postgresql://') or db_url.startswith('postgres://'):
                return self._test_postgresql(db_url)
            elif db_url.startswith('mysql://'):
                return self._test_mysql(db_url)
        except:
            pass
        return {'valid': False}
    
    def _test_mongodb(self, url: str) -> Dict:
        """Test MongoDB connection"""
        try:
            import pymongo
            client = pymongo.MongoClient(url, connectTimeoutMS=5000, serverSelectionTimeoutMS=5000)
            db_names = client.list_database_names()
            client.close()
            return {'valid': True, 'service': 'MongoDB', 'databases': db_names[:10]}
        except:
            pass
        return {'valid': False}
    
    def _test_postgresql(self, url: str) -> Dict:
        """Test PostgreSQL connection"""
        try:
            import psycopg2
            conn = psycopg2.connect(url, connect_timeout=5)
            cursor = conn.cursor()
            cursor.execute("SELECT datname FROM pg_database WHERE datistemplate = false;")
            databases = [row[0] for row in cursor.fetchall()]
            conn.close()
            return {'valid': True, 'service': 'PostgreSQL', 'databases': databases[:10]}
        except:
            pass
        return {'valid': False}
    
    def _test_mysql(self, url: str) -> Dict:
        """Test MySQL connection"""
        try:
            import mysql.connector
            from urllib.parse import urlparse
            parsed = urlparse(url)
            conn = mysql.connector.connect(
                host=parsed.hostname, port=parsed.port or 3306,
                user=parsed.username, password=parsed.password, connection_timeout=5
            )
            cursor = conn.cursor()
            cursor.execute("SHOW DATABASES;")
            databases = [row[0] for row in cursor.fetchall()]
            conn.close()
            return {'valid': True, 'service': 'MySQL', 'databases': databases[:10]}
        except:
            pass
        return {'valid': False}
    
    def _validate_generic_credential(self, value: str) -> Dict:
        """Validate generic credential"""
        if len(value) < 6:
            return {'valid': False}
        return {'valid': False}
    
    def _generate_secret_candidates(self, access_key: str) -> List[str]:
        """Generate secret key candidates"""
        import base64
        return [
            access_key.replace('AKIA', 'SECRET'),
            access_key + 'SECRET',
            'SECRET' + access_key,
            base64.b64encode(access_key.encode()).decode()[:40]
        ][:5]
